零、引言
1、游戏引擎与游戏的界限颇为模糊。我们将注意力集中在引擎本身，包括多个低阶基础系统、渲染引擎、碰撞
   系统、物理模拟、人物动画，及一个称为游戏性基础层的深入讨论。此层包括游戏对象模型、世界编辑器
   事件系统以及脚本系统。我们也将接触游戏性编程，包括玩家机制、摄像机及人工智能。
   
一、导论
1、游戏工作室由工程师、艺术家、游戏设计师、制作人及其他管理/支持人员（市场策划、法律、技术支持、
   行政等）
   
2、大部分二维或三维游戏，会被计算机科学家称为软实时互动、基于代理、计算机模拟的例子

3、大部分电子游戏中，会用数学方式来为一些真实世界的子集建模，从而使这些模型能在计算机中运行。数学
   模型是现实或虚拟世界的模拟。近似化和简化是游戏开发者最有力的两个工具。
   
4、时限：是所有实时模拟的核心概念。电子游戏中，明显的例子是需要屏幕每秒最少更新24次，以制造运动的
   错觉。
   
5、软实时系统指即使错过时限却不会造成灾难性后果。因此，所有游戏都是软实时系统——如果帧数不足，人类
   玩家在现实中不会因此而死亡。
   
6、虚拟世界要用到数学模型。数学模型分为：解析式或数值式

7、《毁灭战士》的软件架构划分为核心软件组件（如三维图形渲染系统、碰撞检测系统和音频系统等）、美术
   资产、游戏世界、构成玩家游戏体验的游戏规则
   
8、游戏引擎很难变成一个通用软件。大部分游戏引擎是针对特定游戏及特定硬件平台所精心制作及微调的。我们
   完全可以说，游戏引擎或中间件组件越通用，在特定平台运行特定游戏的性能就越一般，因为设计高效的软件
   总是需要取舍（例如：渲染室内环境使用BSP（二叉空间分割）树或入口系统，不会渲染被墙或物体遮挡的几何
   图形。室外引擎则可能用不精确的（甚至不使用）遮挡剔除，但它大概会充分利用层次细节技巧，去保证较远
   的景物用较少的三角形来渲染，而距离摄像机较近的几何物体用高清晰的三角形网格）
   
9、不同游戏类型
   第一人称射击（FPS）：注重的技术如下：
                                        高效渲染大型三维虚拟世界
                                        快速反应的摄像机控制及瞄准机制
                                        玩家的虚拟手臂和武器的逼真动画
                                        各式各样的手持武器
                                        宽容的玩家角色运动及碰撞模型
                                        非玩家角色有逼真的动画及智能
                                        小规模在线多人游戏的能力
    平台及其他第三人称游戏：注重的技术如下：
	                                    移动平台、梯子、绳子等运动模式
										用来解谜的环境元素
										第三人称“跟踪摄像机”会一直注释玩家角色
										复杂的摄像机碰撞系统
    格斗游戏：注重的技术：
	                   丰富的格斗动画
					   准确的攻击判断
					   能侦测复杂按钮及摇杆组合的玩家输入系统
					   人群，或相对静态的背景
	竞速游戏：注重的技术：
	                   使用多种“窍门”去渲染遥远的背景
					   三道通常切开成较简单的二维区域，称为“分区”
					   第三人称视角摄像机通常追随在车辆背后，第一人称摄像机置于驾驶舱
					   赛道经过天桥底，必须防止摄像机和背景几何物体碰撞
	实施策略游戏（RTS）：注重的技术：
	                            每个作战单元使用相对较低解析度的模型，使游戏能支持同时显示大量单元
								游戏的设计和进行多是在高度场地形画面上展开的
								除了部署兵力，游戏通常准许玩家在地形上兴建新的建筑物
								用户互动方式通常为单机及范围选取单元
	大型多人在线游戏（MMOG）：
	                      MMOG的子类型有MMO角色扮演游戏（MMORPG）、MMO实施策略游戏（MMORTS）及MMO
						  第一人称射击游戏（MMOFPS）
						  MMOG的核心是一组非常强大的服务器。
	其他游戏类型：
	           体育游戏（篮球）
			   角色扮演游戏（RPG）
			   上帝模拟游戏
			   环境或社会模拟游戏（模拟人生）
			   解谜游戏（俄罗斯方块）
			   非电子游戏移植（象棋、卡牌游戏）
			   基于网页的游戏
			   其他游戏类型：
			   
10、游戏引擎概观
           雷神之锤
		   虚幻引擎
		   Source引擎
		   微软XNA Game Studio
		   开源引擎：
		          OGRE
				  Panda3D
				  Yake
				  Crystal Space
				  Torque及Irrlicht
				  
11、游戏引擎通常由【工具套件】和【运行时组件】两部分构成

12、运行时引擎架构：
    【目标硬件】
    【设备驱动程序】：驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层软件无需理不同硬件
                  版本的通信细节	
    【操作系统】：协调一台计算机上多个程序的执行。游戏不能假设拥有硬件的所有控制权
	【第三方软件开发包（SDK）和中间件】：（SDK提供应用程序接口（API））
	                 数据结构及算法：STL、STLport（可移植、优化的STL实现）、Boost、Loki（泛型编程
					                 模板库）
					 图形：大多数游戏渲染引擎都是建立在硬件接口库之上的：
					        GLide:三维图形SDK
							OpenGL:跨平台三维图形SDK
							DirectX：微软的三维图形SDK
							libgcm
							Edge
					碰撞和物理：
                            Havok
                            PhysX
                            ODE
                    角色动画：
                    人工智能：
                            Kynapse
                    生物力学角色模型：
    【平台独立层】：
          大多数游戏引擎需要运行于不同的平台上。
          平台独立层包装了常用的标准C语言库、操作系统调用及其他基础API，确保包装了的
        接口在所有硬件平台上均为一致。
    【核心系统】：
           断言：一种检查错误的代码
           内存管理：几乎每个游戏引擎都有一个或多个自定义内存分配系统
           数学库：游戏本质上就是高度数学密集的
           自定义数据结构及算法：除非想完全依靠第三方软件包
	【资源管理】：
            每个游戏引擎都有某种形式的资源管理器，提供一个或一组统一接口，去访问任何类
        型的游戏资产及其他引擎输入数据（三维模型资源、纹理资源、材质资源、字体资源、骨骼
		资源、碰撞资源、物理参数、游戏地图、其他）。
    【渲染引擎】：
            任何游戏引擎中，渲染引擎是最大及最复杂的组件之一。渲染引擎的设计采用分层架构
            低阶渲染器：着重于高速渲染丰富的几何图元集合。可以拆分为以下几个组件：
                        图形设备接口：
                                    使用图形SDK，如DirectX及OpenGL，都需要编写代码去枚举
                                图形设备，初始化设备，建立渲染表面等。这些工作通常由图形
                                设备接口的组件负责。
                        其他渲染器组件：
                                    目的是要收集需要提交的几何图元，又称渲染包。包括所有
                                要绘画之物，如网格（mesh）、线表、点表、粒子、地形块、
                                字符串等
			场景图/剔除优化：
                        低阶渲染器绘画所有被提交的几何图形，不太考虑那些图形是否可见。一般
                    由较高层的组件，才能基于可视性判别算法去限制提交的图元数量。
                        非常小的游戏世界可能只需要简单的平截头体剔除算法（去除摄像机看不到
						的物体），比较大的游戏世界则可能需要较高阶的空间细分数据结构，这种
                        数据结构能够快速判别潜在可见集，令渲染更有效率。
			视觉效果：
                        粒子系统
                        贴花系统
                        光照贴图及环境贴图
                        动态阴影
                        全屏后期处理效果
			前端：
                    大多数游戏为了不同目的，都会使用一些二维图形去覆盖三维场景
                这些目的包括:
                            游戏的平视显示器
                            游戏内置菜单、主控台、其他开发工具
                            游戏内置图形用户界面，让玩家操作角色装备，
						配置战斗单元
    【剖析和调试工具】：
        手工插入测量代码，为某些代码计时
        在游戏进行期间，于屏幕显示性能统计数据
        把性能统计写入文件或Excel文件
        计算引擎及子系统所耗内存，显示在屏幕上
        游戏事件录制及回放的能力
    【碰撞和物理】：	
             没有碰撞检测，物体会互相穿透，无法在虚拟世界里合理的互动。一些游戏包含真实或半真
        实的动力学模拟，在游戏中诚“物理系统”，术语：刚体动力学模拟。
    【动画】：
            游戏会用到5种基本动画：
                                精灵/纹理动画
                                刚体层次结构动画
                                骨骼动画
                                每顶点动画
                                变形目标动画
			骨骼动画：当骨骼移动，三维网格的顶点就相继移动。虽然有些引擎支持变形目标及
                  顶点动画，但现今游戏中，骨骼动画仍然是最盛行的动画方式。
                      骨骼网络渲染组件是连接渲染器和动画系统的桥梁。动画系统生成骨骼中
                  所有骨头的姿势，这些姿势以矩阵调色板形式传至渲染引擎。之后，渲染器利用
                  矩阵表去转换顶点，每个顶点用一个或多个矩阵生成最终混合顶点位置。此过程
                  称为蒙皮（skinning）
                       当使用布娃娃时，动画和物理系统便产生耦合。布娃娃是无力的角色，其
                   运动完全由物理系统模拟。
    【人体学接口设备】：玩家输入/输出组件
	            人体学接口设备（HID）从硬件取得原始数据，然后检测按下和释放按钮事件等
	【音频】：
	【在线多人/网络】：多人游戏最少有四种基本形式：
	                                     单屏多人
										 切割屏多人
										 网络多人
										 大型多人在线游戏
	【游戏性基础系统】：
             游戏世界和游戏对象模型
             事件系统：游戏对象总要和其他对象通信。事件驱动架构，常用于典型图形用户界面，
                       也常用于对象间通信
             脚本系统：很多游戏引擎使用脚本语言，使游戏独有游戏性的规则和内容，能更易、
                       更快的开发。没有脚本语言，每次改动引擎中的游戏逻辑或数据结构，都须重新编译、链接方
                       可执行程序。若集成了脚本语言至引擎，要更改游戏逻辑或数据，只需修改脚本代码并重新载入
                       即可。有些引擎容许在游戏运行中重载脚本，其他引擎则需要终止后才能重遍脚本。但两种形式
                       所需的作业时间，总比重遍、重链程序快得多。	
            人工智能基础：提供强大的功能特征，例如：基于A*算法的路径搜寻
    【个别游戏专用子系统】
	
13、工具及资产管道
    游戏引擎都需要读取大量数据，数据形式包括游戏资产、配置文件、脚本等
	【数字内容创作工具】：游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据
	                  皆有美术人员使用数字内容创作（DCC）应用软件制作。
	【资产调节管道】：DCC应用软件所使用的数据格式，鲜有适合直接用于游戏中的。
                  从DCC到游戏引擎的管道，有时候称为资产调节管道，每个引擎都有某种形式的资产调节管道。
    【三维模型/网格数据（三维模型也成为网格/mesh）】：游戏中可见的几何图形，通常由该数据组成
	【骨骼动画数据】；
	             骨骼网格是一种特殊网格，为关节动画而绑定到骨骼层次结构之上。骨骼网格在看不见的骨骼上形成皮肤，因此
				 ，骨骼网格有时候又称为皮肤。骨骼网格的每个顶点包含一组关节索引，表明顶点绑定到骨骼上的哪些关节。每个
				 顶点也包含一组关节权重，决定每个关节对该顶点的影响程度。
				 游戏需要三种数据渲染骨骼网格：
				                               网格本身
											   骨骼层次架构
											   一个至多个动画片段
	【音频数据】：
    【粒子系统数据】：很多游戏采用复杂的粒子效果
    【游戏世界数据及世界编辑器】：

二、专业工具
1、版本控制:git、svn等

2、vs
    【源文件、头文件及翻译单元】：编译器每次只翻译一个c++源文件至机器码，所以在技术上，源文件称为翻译单元
	                          c++编译器并不知悉头文件，实际情况是，c++预处理器预先把每个#include语句替换
							  为相对应的头文件内容，然后再把翻译单元交送编译器。
    【程序库、可执行文件及动态链接库】：
                                 编译翻译单元后，输出的机器码会存储在对象文件（windows下采用.obj扩展名，在
								 基于UNIX的系统中则是.o）中。对象文件中的机器码是：可重定位的、未链接的
                                 对象文件可以集合成程序库。
                                 链接器把对象文件和程序库链接成可执行文件。
                                 动态链接库（DLL）是一种特殊的库，其行为像正常的静态链接库和可执行文件的混合体。
								 DLL像库，因为它包含函数，供其他多个不同的可执行文件调用。然而，DLL也像可执行文件，
								 因为操作系统能独立载入DLL，而DLL可包含启动及终止代码，其执行方式和c++可执行文件的main()
								 函数相似。
    【项目及解决方案】：项目是源文件的集合。编译项目会产生库、可执行文件或DLL。项目存储为.vcproj扩展名的项目文件
                        解决方案文件（.sln）负责容纳及管理项目的集合。包含彼此有依赖性及没依赖性的项目，用以生成一个或多个库、
                        可执行文件及DLL
    【……】

3、剖析工具

4、内存泄漏和损坏检测

5、其他工具

三、游戏软件工程基础

四、游戏所需的三维数学
1、大部分3D游戏都是由虚拟世界里的三维物体组成的。游戏引擎须记录这些物体的位置、定向和比例

2、迪卡儿坐标系是游戏程序员最常用的坐标系
   右手坐标系：右手握拳，伸出拇指指向x轴、食指指向y轴、中指指向z轴
   左右手坐标系相互转换：只需把其中一个轴反转，并保留另外两个轴不变即可

3、三维图形程序员一般以左手坐标系工作，并以y轴向上、x轴向右、z轴向观察者离去

4、位置矢量：矢量有时候可以用来表示点，只要把其尾固定在坐标系的原点
   方向矢量：一个矢量可移至三维空间中的任何位置，只要该矢量的方向和大小保持不变，无论在哪个位置，皆为同一矢量

5、正交单位矢量（笛卡儿基矢量）

6、点和方向的加减
    点+点=无意义

7、归一化和单位矢量、法矢量

8、点积和投影
    矢量间可以相乘，但和标量不同，矢量有多种乘法：
                                 点积：又称标量积或内积 ，
								 叉积：又称为矢量积或外积
	点积：两矢量的点积结果是一个标量a.b，也可以写成两矢量的模相乘后，再乘以两矢量间夹角的余弦
	叉积：会产生另外一个矢量，该矢量垂直于原来的两个相乘矢量，叉积运算只定义于三维空间
	      叉积的模等于两矢量各自的模的积再乘以两矢量夹角的正弦
		  叉积不符合交换律，但叉积符合反交换律

9、点和矢量的线性插值
   线性插值是一个简单的数学运算，用来计算两个已知点的中间点。此运算名称：LERP

10、矩阵：矩阵便于表示线性变换，如平移、旋转和缩放
    我们视3x3矩阵的行和列为三维矢量。若某3x3矩阵中的所有行及列矢量为单位矢量，则该矩阵称为特殊正交矩阵
	、各向同性矩阵或标准正交矩阵。这种矩阵表示纯旋转
	在某些情况下，4x4矩阵可表示任意三维变换，包括平移、旋转和缩放。这种矩阵称为变换矩阵。利用矩阵乘法可以
	把表示为矩阵的变换，施于点或矢量。
	仿射矩阵是一种4x4变换矩阵，他能维持直线在变换前后的平行性以及相对的距离比，但不一定维持直线在变换前后
	绝对长度及角度。由平移、旋转、缩放及切变所组合而成的变换都是仿射矩阵

11、矩阵乘法
    仅当两矩阵的内维相等时，两矩阵才可相乘。矩阵乘法并不符合交换律
	
12、点和矢量都可以表示为行矩阵或列矩阵，此选择会影响矩阵乘法的书写次序。原因是进行矩阵乘法时，两矩阵的内部
    维数必须相等
	本书采用行矢量惯例，因为从左至右最符合阅读习惯

13、单位矩阵：它乘以任何其他矩阵，都会得出和原来一样的矩阵。对角线上的元素皆为1，其他元素为0

14、矩阵A的逆矩阵能还原矩阵A的变换。若一个矩阵乘以它的逆矩阵，结果必然是单位矩阵。并非所有矩阵都有逆矩阵，然而
    仿射矩阵都有逆矩阵。
    矩阵串接后求逆，相当于反向串接各个矩阵的逆矩阵

15、转置矩阵:转置矩阵就是把原来矩阵以主对角线为对称轴做反射。即原来矩阵的行变成转置矩阵的列。标准正交矩阵（纯旋转）
    的逆矩阵和转置矩阵是一样的。计算转置矩阵比计算一般逆矩阵快得多
    和逆矩阵相同，矩阵串接的转置，为反向串接各个矩阵的转置	
	
16、三维中的旋转可以用3x3矩阵表示。但3x3矩阵不能表示平移
    当点或矢量从三维延伸至四维，便成为齐次坐标。在游戏引擎中，大多数三维矩阵都采用4x4矩阵，与4元素的齐次坐标点或矢量
    进行运算。

17、在数学上，点（位置矢量）和方向矢量的处理方法有细微差别。当用矩阵变换一个点时，平移、旋转、缩放都会施于该点上。但是，
    当用矩阵变换一个方向矢量时，就要忽略矩阵的平移效果。因为方向矢量本身并无平移，加上平移会改变其模，这并非我们所要的。
    在齐次坐标中，可以把点的w分量设为1，把方向矢量的w分量设为0

18、基础变换矩阵：平移、旋转、缩放
    任何仿射变换矩阵都能由一连串表示纯平移、纯旋转、纯缩放及纯切变的4x4矩阵串接而成。
    4x4变换矩阵可切割为4个组成部分：
                          左上的3x3矩阵，代表旋转及缩放
                           1x3平移矢量t
                           3x1零矢量
                           矩阵右下角的标量1		
    4x3矩阵：4x4仿射矩阵的最右侧必然是一列[0 0 0 1](T)的矢量。因此，游戏程序员可略去第4列，以节省内存。
    游戏数学库里经常会遇到4x3仿射矩阵

19、坐标空间，游戏业界将坐标系称为坐标空间
       【模型空间】（也可称为物体空间或局部空间）：模型空间的原点可置于物体的中心位置
	                多数游戏对象都有先天的定向性。如，飞机的机头、机翼。3个欧拉角——俯仰角、偏航角、滚动角经常用来表示飞机的定向
	                可以用（L,U,F）基矢量去定义偏航角、俯仰角、滚动角
                    俯仰角：绕L或R旋转的角度
                    偏航角：绕U旋转的角度
                    滚动角：绕F旋转的角度
        【世界空间】：世界空间是一个固定坐标空间。游戏世界中所有物体的位置、定向和缩放都会用此空间表示。
                  世界空间的原点可置于任何地方，但通常会把原点置于接近可玩游戏空间的中心，因为当（x,y,z）的值非常大时，浮点小数会
                  出现精度问题，这样设置可使精度问题将至最低程度	
		【观察空间】：又称为【摄像机空间】，是固定于摄像机的坐标系。观察空间原点置于摄像机的焦点。

20、基的变更：在游戏和计算机图形学里，经常把物体的位置、定向和缩放从某个坐标系转换至另一个坐标系。我们城府此运算为基的变更。
    坐标系是相对的。世界空间并无父，因为它是坐标空间树的根，其他坐标空间则直接或间接地相对于世界空间。
    构建改变基的矩阵：把点或方向从任何子坐标系C变换至其父坐标系P的矩阵	
	变换法矢量：若点或矢量可用3x3矩阵将其从空间A旋转至空间B，则法矢量n可使用该矩阵的逆转置矩阵做变换。
	
21、内存中存储矩阵
    大多数游戏引擎会使用C/C++二维数组中的每行去存储矢量

22、【四元数】：四元数看似四维矢量，但行为上有很大区别。通常把四元数写成非斜非粗字体
    单位长度的四元数能代表三维旋转
    单位四元数可以视觉化为三维矢量加上第四维的标量坐标

23、必须谨记：两个四元数相加的和并不能代表三维旋转，因为该四元数并不是单位长度。因此，在游戏引擎中不会看见四元数
               的和，除非他们用某方法缩放至符合单位长度的要求。

24、四元数乘法，代表旋转的合成旋转
    共轭及逆四元数，你四元数和原四元数的乘积会变成标量1
    计算逆四元数比计算3x3逆矩阵快得多，在某些情况下，可以利用这一特点优化引擎

25、以四元数旋转矢量
    首先要把矢量重写为四元数形式。把标量项设为0。
    要以四元数q旋转矢量V，须用q前乘以矢量v，再后乘以逆四元数q(-1)

26、在游戏引擎的动画、动力学及摄像机系统中，有许多场合都需要旋转型的插值。凭借四元数的帮助，对旋转插值与
    对矢量和点插值同样简单
    【线性插值（LERP）】：最简单快速的旋转插值方法，就是套用四维矢量的线性插值（LERP）至四元数。注意插值后的四元数需要再归一，这是
    因为LERP运算一般不保证矢量长度。
	【球面线性插值（SLERP）】：LERP问题在于，它没考虑四元数其实是四维超球上的点。LERP实际上是沿着超球的弦上进行插值，这样会导致，当角度以
	恒定速改变时，旋转动画并非以恒定角速度进行。旋转在两端看似较慢，在动画中间就会很快。
	
27、比较各种旋转表达方式：
     【欧拉角】：偏航角、俯仰角、滚动角。围绕单轴的旋转很容易插值。对于任意方向的旋转轴，欧拉角则不能轻易插值，而且会遭遇万向节死锁
	 【3x3矩阵】：旋转可通过矩阵乘法。而4x4矩阵更可用来表示仿射变换（旋转、平移、缩放）。旋转矩阵不容易插值，而且相对欧拉角，旋转矩阵
	              需要大量存储空间
	 【轴角】：一个以单位矢量定义的旋转轴，再加上一个标量定义的旋转角，也可用来表示旋转。
               轴角不能简单地进行插值。此外，轴角形式的旋转不能直接施于点或矢量，而须先转换为矩阵或四元数
     【四元数】：单位长度的四元数可表示旋转，其形式和轴角相似。这两个表达式的主要区别在于，四元数的旋转轴矢量的长度为旋转半角的正弦，
                 并且第4分量不是旋转角，而是旋转半角的余弦。
                 对比轴角，四元数带来两个极大好处。一、四元数乘法能串接旋转，并把旋转直接施于点和矢量。二、可轻易的用LERP或SLERP进行旋转
                 插值。四元数只需存储为4个浮点数，这也优于矩阵。
     【SQT变换】：单凭四元数只能表示旋转，而4x4矩阵则可表示任意仿射变换（旋转、平移、缩放）	

28、其他数学对象

29、硬件加速的SIMD运算

30、产生随机数 
	
	
	
            	
	           